name: Documentation Quality Check

on:
  push:
    branches: [ main, develop ]
    paths: [ 'docs/**', 'mkdocs.yml', 'overrides/**' ]
  pull_request:
    branches: [ main, develop ]
    paths: [ 'docs/**', 'mkdocs.yml', 'overrides/**' ]

permissions:
  contents: read
  pull-requests: write

jobs:
  quality-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: quality-check-${{ hashFiles('**/requirements.txt', '.github/workflows/quality-check.yml') }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install mkdocs-material
          pip install mkdocs-git-revision-date-localized-plugin
          pip install beautifulsoup4
          pip install lxml
          pip install html5lib
          pip install markdown
          pip install pymdown-extensions

      - name: Create quality check script
        run: |
          cat > quality_check.py << 'EOF'
          #!/usr/bin/env python3
          """
          MkDocsæ–‡æ›¸å“è³ªãƒã‚§ãƒƒã‚¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
          
          æ¤œå‡ºã™ã‚‹ã‚¨ãƒ©ãƒ¼:
          - æ”¹è¡Œãšã‚Œï¼ˆé€£ç¶šæ”¹è¡Œã€ä¸é©åˆ‡ãªæ”¹è¡Œï¼‰
          - MarkdownãŒé©ç”¨ã•ã‚Œã¦ã„ãªã„ç®‡æ‰€
          - HTMLã‚¿ã‚°å†…ã§MarkdownãŒå´©ã‚Œã‚‹
          - *ã‚„-ãŒå¤‰æ›ã•ã‚Œã¦ã„ãªã„
          - æ”¹è¡Œã•ã‚Œãªã„å•é¡Œ
          """
          
          import os
          import re
          import sys
          import json
          import subprocess
          from pathlib import Path
          from bs4 import BeautifulSoup
          import markdown
          from markdown.extensions import admonition, toc, tables, attr_list, md_in_html
          from pymdownx import superfences, details, tabbed, tasklist, highlight, inlinehilite, snippets, critic, caret, keys, mark, tilde, emoji
          
          class QualityChecker:
              def __init__(self):
                  self.errors = []
                  self.warnings = []
                  self.markdown_processor = markdown.Markdown(
                      extensions=[
                          'admonition',
                          'pymdownx.details', 
                          'pymdownx.superfences',
                          'pymdownx.highlight',
                          'pymdownx.inlinehilite',
                          'pymdownx.snippets',
                          'pymdownx.tabbed',
                          'pymdownx.tasklist',
                          'attr_list',
                          'md_in_html',
                          'toc',
                          'tables',
                          'footnotes',
                          'pymdownx.critic',
                          'pymdownx.caret',
                          'pymdownx.keys',
                          'pymdownx.mark',
                          'pymdownx.tilde',
                          'pymdownx.emoji'
                      ]
                  )
                  
              def check_line_breaks(self, content, filepath):
                  """æ”¹è¡Œãšã‚Œã®æ¤œå‡º"""
                  lines = content.split('\n')
                  
                  # é€£ç¶šã™ã‚‹ç©ºè¡Œï¼ˆ3è¡Œä»¥ä¸Šï¼‰
                  empty_count = 0
                  for i, line in enumerate(lines):
                      if line.strip() == '':
                          empty_count += 1
                      else:
                          if empty_count >= 3:
                              self.errors.append({
                                  'type': 'excessive_blank_lines',
                                  'file': filepath,
                                  'line': i - empty_count + 1,
                                  'message': f'{empty_count}è¡Œã®é€£ç¶šç©ºè¡ŒãŒã‚ã‚Šã¾ã™',
                                  'severity': 'warning'
                              })
                          empty_count = 0
                  
                  # è¡Œæœ«ã®ä¸è¦ãªã‚¹ãƒšãƒ¼ã‚¹
                  for i, line in enumerate(lines):
                      if line.rstrip() != line:
                          self.errors.append({
                              'type': 'trailing_whitespace',
                              'file': filepath,
                              'line': i + 1,
                              'message': 'è¡Œæœ«ã«ä¸è¦ãªã‚¹ãƒšãƒ¼ã‚¹ãŒã‚ã‚Šã¾ã™',
                              'severity': 'error'
                          })
                  
                  # ãƒªã‚¹ãƒˆé …ç›®ã®æ”¹è¡Œä¸å‚™
                  for i, line in enumerate(lines):
                      if re.match(r'^[\s]*[-*+]\s', line):
                          # ãƒªã‚¹ãƒˆé …ç›®ã®æ¬¡ã®è¡Œã‚’ãƒã‚§ãƒƒã‚¯
                          if i + 1 < len(lines) and lines[i + 1].strip() != '':
                              if not re.match(r'^[\s]*[-*+]\s', lines[i + 1]) and not lines[i + 1].startswith('  '):
                                  self.warnings.append({
                                      'type': 'list_formatting',
                                      'file': filepath,
                                      'line': i + 2,
                                      'message': 'ãƒªã‚¹ãƒˆé …ç›®ã®ç¶™ç¶šè¡Œã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãŒä¸é©åˆ‡ã§ã™',
                                      'severity': 'warning'
                                  })
          
              def check_markdown_conversion(self, content, filepath):
                  """Markdownå¤‰æ›ã®å•é¡Œã‚’æ¤œå‡º"""
                  
                  # æœªå¤‰æ›ã®*å¼·èª¿*
                  asterisk_pattern = r'(?<!\*)\*([^*\n]+)\*(?!\*)'
                  matches = re.finditer(asterisk_pattern, content)
                  for match in matches:
                      line_num = content[:match.start()].count('\n') + 1
                      # HTMLã‚¿ã‚°å†…ã‚„ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å†…ã¯é™¤å¤–
                      if not self._is_in_code_block(content, match.start()) and not self._is_in_html_tag(content, match.start()):
                          self.warnings.append({
                              'type': 'potential_markdown_issue',
                              'file': filepath,
                              'line': line_num,
                              'message': f'å¼·èª¿è¨˜æ³•ãŒæ­£ã—ãå¤‰æ›ã•ã‚Œã¦ã„ãªã„å¯èƒ½æ€§: {match.group()}',
                              'severity': 'warning'
                          })
                  
                  # æœªå¤‰æ›ã®-ãƒªã‚¹ãƒˆ-
                  list_pattern = r'^[\s]*-\s+(?![*-]\s)'
                  for i, line in enumerate(content.split('\n')):
                      if re.match(list_pattern, line):
                          # å‰å¾Œã®è¡Œã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãƒªã‚¹ãƒˆæ§‹é€ ãŒé©åˆ‡ã‹ç¢ºèª
                          lines = content.split('\n')
                          if i > 0 and i < len(lines) - 1:
                              prev_line = lines[i-1].strip()
                              next_line = lines[i+1].strip()
                              
                              # ãƒªã‚¹ãƒˆå‰å¾Œã®ç©ºè¡Œãƒã‚§ãƒƒã‚¯
                              if prev_line != '' and not re.match(r'^[\s]*[-*+]\s', prev_line):
                                  if prev_line and not prev_line.endswith(':'):
                                      self.warnings.append({
                                          'type': 'list_spacing',
                                          'file': filepath,
                                          'line': i + 1,
                                          'message': 'ãƒªã‚¹ãƒˆé …ç›®ã®å‰ã«ç©ºè¡ŒãŒå¿…è¦ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“',
                                          'severity': 'info'
                                      })
              
              def check_html_markdown_conflicts(self, content, filepath):
                  """HTMLã‚¿ã‚°å†…ã®Markdownå´©ã‚Œã‚’æ¤œå‡º"""
                  
                  # HTMLã‚¿ã‚°å†…ã®Markdownè¨˜æ³•ã‚’æ¤œå‡º
                  html_tag_pattern = r'<([^>]+)>(.*?)</\1>'
                  matches = re.finditer(html_tag_pattern, content, re.DOTALL)
                  
                  for match in matches:
                      tag_content = match.group(2)
                      if re.search(r'[*_`#]', tag_content):
                          line_num = content[:match.start()].count('\n') + 1
                          self.errors.append({
                              'type': 'html_markdown_conflict',
                              'file': filepath,
                              'line': line_num,
                              'message': f'HTMLã‚¿ã‚°å†…ã«Markdownè¨˜æ³•ãŒã‚ã‚Šã¾ã™: {match.group(1)}',
                              'severity': 'error'
                          })
              
              def check_hardline_breaks(self, content, filepath):
                  """æ”¹è¡Œã•ã‚Œãªã„å•é¡Œã‚’æ¤œå‡º"""
                  lines = content.split('\n')
                  
                  for i, line in enumerate(lines):
                      # é•·ã™ãã‚‹è¡Œï¼ˆæ—¥æœ¬èªã§ã¯80æ–‡å­—ç¨‹åº¦ãŒç›®å®‰ï¼‰
                      if len(line) > 100:
                          # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚„è¡¨ã¯é™¤å¤–
                          if not line.strip().startswith('|') and not line.strip().startswith('    '):
                              self.warnings.append({
                                  'type': 'long_line',
                                  'file': filepath,
                                  'line': i + 1,
                                  'message': f'è¡ŒãŒé•·ã™ãã¾ã™ ({len(line)}æ–‡å­—)',
                                  'severity': 'info'
                              })
                      
                      # æ–‡æœ«ã«ãƒ”ãƒªã‚ªãƒ‰ãŒã‚ã‚‹ã®ã«æ”¹è¡ŒãŒãªã„
                      if re.search(r'ã€‚\s*[^\s]', line):
                          self.warnings.append({
                              'type': 'missing_line_break',
                              'file': filepath,
                              'line': i + 1,
                              'message': 'æ–‡æœ«ã®å¾Œã«æ”¹è¡ŒãŒã‚ã‚Šã¾ã›ã‚“',
                              'severity': 'info'
                          })
              
              def _is_in_code_block(self, content, position):
                  """æŒ‡å®šä½ç½®ãŒã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å†…ã‹ã©ã†ã‹åˆ¤å®š"""
                  before_content = content[:position]
                  code_blocks = re.findall(r'```.*?```', before_content, re.DOTALL)
                  inline_codes = re.findall(r'`[^`]*`', before_content)
                  
                  # ç°¡æ˜“çš„ãªåˆ¤å®šï¼ˆã‚ˆã‚Šç²¾å¯†ãªå®Ÿè£…ãŒå¿…è¦ãªå ´åˆã‚ã‚Šï¼‰
                  return '```' in before_content.split('\n')[-1] or '`' in before_content.split('\n')[-1]
              
              def _is_in_html_tag(self, content, position):
                  """æŒ‡å®šä½ç½®ãŒHTMLã‚¿ã‚°å†…ã‹ã©ã†ã‹åˆ¤å®š"""
                  before_content = content[:position]
                  return '<' in before_content.split('\n')[-1] and '>' not in before_content.split('\n')[-1]
              
              def check_file(self, filepath):
                  """å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒã‚§ãƒƒã‚¯"""
                  try:
                      with open(filepath, 'r', encoding='utf-8') as f:
                          content = f.read()
                      
                      self.check_line_breaks(content, filepath)
                      self.check_markdown_conversion(content, filepath)
                      self.check_html_markdown_conflicts(content, filepath)
                      self.check_hardline_breaks(content, filepath)
                      
                  except Exception as e:
                      self.errors.append({
                          'type': 'file_error',
                          'file': filepath,
                          'line': 0,
                          'message': f'ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼: {str(e)}',
                          'severity': 'error'
                      })
              
              def check_build_output(self):
                  """MkDocsãƒ“ãƒ«ãƒ‰å¾Œã®HTMLãƒã‚§ãƒƒã‚¯"""
                  site_dir = Path('site')
                  if not site_dir.exists():
                      return
                  
                  for html_file in site_dir.rglob('*.html'):
                      try:
                          with open(html_file, 'r', encoding='utf-8') as f:
                              html_content = f.read()
                          
                          soup = BeautifulSoup(html_content, 'html.parser')
                          
                          # ç©ºã®ãƒªã‚¹ãƒˆé …ç›®ãƒã‚§ãƒƒã‚¯
                          for li in soup.find_all('li'):
                              if not li.get_text(strip=True):
                                  self.errors.append({
                                      'type': 'empty_list_item',
                                      'file': str(html_file),
                                      'line': 0,
                                      'message': 'ç©ºã®ãƒªã‚¹ãƒˆé …ç›®ãŒã‚ã‚Šã¾ã™',
                                      'severity': 'warning'
                                  })
                          
                          # å¤‰æ›ã•ã‚Œã¦ã„ãªã„Markdownè¨˜æ³•ã‚’ãƒã‚§ãƒƒã‚¯
                          text_content = soup.get_text()
                          if re.search(r'(?<!\*)\*[^*]+\*(?!\*)', text_content):
                              self.warnings.append({
                                  'type': 'unconverted_markdown',
                                  'file': str(html_file),
                                  'line': 0,
                                  'message': 'å¤‰æ›ã•ã‚Œã¦ã„ãªã„Markdownè¨˜æ³•ãŒã‚ã‚Šã¾ã™',
                                  'severity': 'warning'
                              })
                              
                      except Exception as e:
                          self.errors.append({
                              'type': 'html_parse_error',
                              'file': str(html_file),
                              'line': 0,
                              'message': f'HTMLè§£æã‚¨ãƒ©ãƒ¼: {str(e)}',
                              'severity': 'error'
                          })
              
              def run_checks(self):
                  """å…¨ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ"""
                  docs_dir = Path('docs')
                  if not docs_dir.exists():
                      print("docsãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                      return False
                  
                  # Markdownãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
                  for md_file in docs_dir.rglob('*.md'):
                      self.check_file(str(md_file))
                  
                  # MkDocsã‚’ãƒ“ãƒ«ãƒ‰
                  try:
                      subprocess.run(['mkdocs', 'build'], check=True, capture_output=True)
                      self.check_build_output()
                  except subprocess.CalledProcessError as e:
                      self.errors.append({
                          'type': 'build_error',
                          'file': 'mkdocs.yml',
                          'line': 0,
                          'message': f'MkDocsãƒ“ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼: {e.stderr.decode()}',
                          'severity': 'error'
                      })
                  
                  return len([e for e in self.errors if e['severity'] == 'error']) == 0
              
              def generate_report(self):
                  """ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ"""
                  error_count = len([e for e in self.errors if e['severity'] == 'error'])
                  warning_count = len([e for e in self.errors + self.warnings if e['severity'] == 'warning'])
                  info_count = len([e for e in self.errors + self.warnings if e['severity'] == 'info'])
                  
                  print(f"\nğŸ“Š å“è³ªãƒã‚§ãƒƒã‚¯çµæœ")
                  print(f"ã‚¨ãƒ©ãƒ¼: {error_count}")
                  print(f"è­¦å‘Š: {warning_count}")
                  print(f"æƒ…å ±: {info_count}")
                  
                  all_issues = self.errors + self.warnings
                  all_issues.sort(key=lambda x: (x['file'], x['line']))
                  
                  for issue in all_issues:
                      severity_icon = {'error': 'âŒ', 'warning': 'âš ï¸', 'info': 'â„¹ï¸'}[issue['severity']]
                      print(f"\n{severity_icon} {issue['file']}:{issue['line']}")
                      print(f"   {issue['message']}")
                      print(f"   ç¨®é¡: {issue['type']}")
                  
                  # GitHub Actionsç”¨ã®ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
                  if os.getenv('GITHUB_ACTIONS'):
                      for issue in all_issues:
                          level = 'error' if issue['severity'] == 'error' else 'warning'
                          print(f"::{level} file={issue['file']},line={issue['line']}::{issue['message']}")
                  
                  return error_count == 0
          
          if __name__ == '__main__':
              checker = QualityChecker()
              success = checker.run_checks()
              success = checker.generate_report() and success
              
              if not success:
                  print("\nâŒ å“è³ªãƒã‚§ãƒƒã‚¯ã§å•é¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ")
                  sys.exit(1)
              else:
                  print("\nâœ… å“è³ªãƒã‚§ãƒƒã‚¯ãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ")
                  sys.exit(0)
          EOF

      - name: Run quality checks
        id: quality-check
        run: |
          python quality_check.py
          echo "quality_check_result=$?" >> $GITHUB_OUTPUT

      - name: Comment PR
        if: github.event_name == 'pull_request' && steps.quality-check.outputs.quality_check_result != '0'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            
            // å“è³ªãƒã‚§ãƒƒã‚¯çµæœã‚’èª­ã¿è¾¼ã¿ï¼ˆç°¡ç•¥åŒ–ï¼‰
            const comment = `## ğŸ“ æ–‡æ›¸å“è³ªãƒã‚§ãƒƒã‚¯çµæœ
            
            æ–‡æ›¸ã®å“è³ªãƒã‚§ãƒƒã‚¯ã§å•é¡ŒãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚è©³ç´°ã¯ä¸Šè¨˜ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œãƒ­ã‚°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚
            
            ã‚ˆãã‚ã‚‹å•é¡Œ:
            - **æ”¹è¡Œãšã‚Œ**: é€£ç¶šã™ã‚‹ç©ºè¡Œã€è¡Œæœ«ã‚¹ãƒšãƒ¼ã‚¹
            - **Markdownå¤‰æ›ã‚¨ãƒ©ãƒ¼**: \`*å¼·èª¿*\`ãŒæ­£ã—ãå¤‰æ›ã•ã‚Œãªã„
            - **HTMLã‚¿ã‚°å†…ã®Markdownå´©ã‚Œ**: HTMLã‚¿ã‚°å†…ã§Markdownè¨˜æ³•ã‚’ä½¿ç”¨
            - **ãƒªã‚¹ãƒˆè¨˜æ³•ã®å•é¡Œ**: \`-\`ã‚„\`*\`ãŒå¤‰æ›ã•ã‚Œãªã„
            - **æ”¹è¡Œã®å•é¡Œ**: é•·ã™ãã‚‹è¡Œã€ä¸é©åˆ‡ãªæ”¹è¡Œä½ç½®
            
            ä¿®æ­£å¾Œã€å†åº¦ãƒ—ãƒƒã‚·ãƒ¥ã—ã¦ãã ã•ã„ã€‚`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Upload quality report
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: quality-check-report
          path: |
            quality_check.py
            site/
          retention-days: 7